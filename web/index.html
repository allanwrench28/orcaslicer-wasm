<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Orca WASM Slicer Test</title>
	<style>
		body { font-family: sans-serif; margin: 2em; }
		#output { white-space: pre-wrap; background: #f8f8f8; padding: 1em; border-radius: 6px; }
	</style>
</head>
<body>
				<h1>Orca WASM Slicer Test</h1>
				<input type="file" id="stlInput" accept=".stl" />
				<button id="sliceBtn" disabled>Slice</button>
				<div id="output"></div>
				<script src="/wasm/slicer.js" onload="window.createSlicerModule = OrcaModule;"></script>
				<script>
					let slicerModule;
					let stlData;
					const outputDiv = document.getElementById('output');
					const sliceBtn = document.getElementById('sliceBtn');
					const stlInput = document.getElementById('stlInput');
					const textDecoder = new TextDecoder('utf-8');

					function showError(msg) {
						outputDiv.textContent = 'Error: ' + msg;
						outputDiv.style.color = 'red';
						sliceBtn.disabled = true;
					}
					function showInfo(msg) {
						outputDiv.textContent = msg;
						outputDiv.style.color = '';
					}
					function validateSTL(file) {
						if (!file) return 'No file selected.';
						if (!file.name.toLowerCase().endsWith('.stl')) return 'File is not an STL.';
						if (file.size < 84) return 'STL file is too small.';
						return null;
					}
					function describeSliceError(code) {
						switch (code) {
							case -1: return 'Failed to load STL into Orca model.';
							case -2: return 'Orca model contained no printable objects.';
							case -3: return 'Failed while generating G-code file.';
							case -4: return 'Internal Orca exception during slicing.';
							default: return `Unknown error code ${code}`;
						}
					}
					function attachSliceShim(Module) {
						if (Module.__orcaSliceShimAttached) return true;
						if (typeof Module._orc_slice !== 'function' ||
							typeof Module._malloc !== 'function' ||
							typeof Module._orc_free !== 'function' ||
							typeof Module._free !== 'function') {
							const exportedFns = Object.keys(Module).filter(k => typeof Module[k] === 'function');
							showError('Required WASM exports missing. Expected _orc_slice/_orc_free/_malloc/_free. Exported functions: ' + exportedFns.join(', '));
							return false;
						}

						Module.sliceSTL = async function sliceSTL(buffer) {
							const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
							const len = bytes.byteLength;
							if (len === 0) {
								return '';
							}

							const inPtr = Module._malloc(len);
							if (!inPtr) throw new Error('Failed to allocate memory for STL input.');
							Module.HEAPU8.set(bytes, inPtr);

							const outPtrPtr = Module._malloc(4);
							const outLenPtr = Module._malloc(4);
							if (!outPtrPtr || !outLenPtr) {
								if (inPtr) Module._free(inPtr);
								if (outPtrPtr) Module._free(outPtrPtr);
								if (outLenPtr) Module._free(outLenPtr);
								throw new Error('Failed to allocate output pointer storage.');
							}

							Module.HEAP32[outPtrPtr >> 2] = 0;
							Module.HEAP32[outLenPtr >> 2] = 0;

							let gcodePtr = 0;
							let gcodeLen = 0;
							try {
								const rc = Module._orc_slice(inPtr, len, outPtrPtr, outLenPtr);
								gcodePtr = Module.HEAP32[outPtrPtr >> 2] >>> 0;
								gcodeLen = Module.HEAP32[outLenPtr >> 2] >>> 0;

								if (rc !== 0) {
									if (gcodePtr) Module._orc_free(gcodePtr);
									throw new Error(describeSliceError(rc));
								}

								if (!gcodePtr || gcodeLen === 0) {
									return '';
								}

								const gcodeBytes = Module.HEAPU8.slice(gcodePtr, gcodePtr + gcodeLen);
								const gcodeText = textDecoder.decode(gcodeBytes);
								Module._orc_free(gcodePtr);
								return gcodeText;
							} finally {
								Module._free(inPtr);
								Module._free(outPtrPtr);
								Module._free(outLenPtr);
							}
						};

						Module.__orcaSliceShimAttached = true;
						return true;
					}

					async function ensureWasmReady() {
						if (!window.createSlicerModule) {
							showError('WASM loader not initialized. Check if /wasm/slicer.js loaded.');
							return false;
						}
						if (!slicerModule) {
							try {
								slicerModule = await window.createSlicerModule();
							} catch (err) {
								showError('WASM module failed to initialize: ' + err);
								return false;
							}
						}
						if (!slicerModule) {
							showError('WASM module is undefined after initialization.');
							return false;
						}
						return attachSliceShim(slicerModule);
					}

					stlInput.addEventListener('change', async (e) => {
						const file = e.target.files[0];
						const validationError = validateSTL(file);
						if (validationError) {
							showError(validationError);
							stlData = null;
							return;
						}
						try {
							stlData = await file.arrayBuffer();
							showInfo(`Loaded file: ${file.name} (${file.size} bytes)`);
							// Enable slice button only if WASM is ready and STL is valid
							if (await ensureWasmReady()) {
								sliceBtn.disabled = false;
							} else {
								sliceBtn.disabled = true;
							}
						} catch (err) {
							showError('Failed to read STL file: ' + err);
							stlData = null;
						}
					});

					sliceBtn.addEventListener('click', async () => {
						if (!stlData) {
							showError('No STL data loaded.');
							return;
						}
						if (!(await ensureWasmReady())) {
							return;
						}
						sliceBtn.disabled = true;
						showInfo('Slicing...');
						try {
							const result = await slicerModule.sliceSTL(new Uint8Array(stlData));
							if (!result || result.length === 0) {
								showError('Slicing completed but no G-code was returned.');
								return;
							}
							showInfo('G-code output:\n' + result);
						} catch (err) {
							showError('Slicing failed: ' + err);
						} finally {
							if (stlData) {
								sliceBtn.disabled = false;
							}
						}
					});
				</script>
</body>
</html>
