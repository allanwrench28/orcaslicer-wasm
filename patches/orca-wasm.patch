diff --git a/CMakeLists.txt b/CMakeLists.txt
index f58a5876ed..37ca7f512a 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -517,12 +517,22 @@ target_include_directories(boost_headeronly SYSTEM INTERFACE ${Boost_INCLUDE_DIR
 target_link_libraries(boost_libs INTERFACE boost_headeronly ${Boost_LIBRARIES})
 
 # Find and configure intel-tbb
+# TBB is optional when building for WASM; fall back to shims when disabled.
+set(TBB_FOUND FALSE)
 if(SLIC3R_STATIC)
     set(TBB_STATIC 1)
 endif()
 set(TBB_DEBUG 1)
 set(CMAKE_MAP_IMPORTED_CONFIG_RELWITHDEBINFO RelWithDebInfo Release "")
-find_package(TBB REQUIRED)
+if(NOT DEFINED CMAKE_DISABLE_FIND_PACKAGE_TBB OR NOT CMAKE_DISABLE_FIND_PACKAGE_TBB)
+    find_package(TBB)
+endif()
+if(TBB_FOUND)
+    add_compile_definitions(SLIC3R_USE_TBB=1)
+else()
+    set(TBB_FOUND FALSE)
+    add_compile_definitions(SLIC3R_USE_TBB=0)
+endif()
 # include_directories(SYSTEM ${TBB_INCLUDE_DIRS})
 # add_definitions(${TBB_DEFINITIONS})
 # if(MSVC)
diff --git a/deps_src/hidapi/CMakeLists.txt b/deps_src/hidapi/CMakeLists.txt
index efb7f62ebe..3f2fc36da8 100644
--- a/deps_src/hidapi/CMakeLists.txt
+++ b/deps_src/hidapi/CMakeLists.txt
@@ -1,3 +1,10 @@
+if (CMAKE_SYSTEM_NAME STREQUAL "Emscripten" OR EMSCRIPTEN)
+    add_library(hidapi INTERFACE)
+    target_include_directories(hidapi INTERFACE
+        ${CMAKE_CURRENT_SOURCE_DIR}/include
+    )
+    return()
+endif()
 
 if (WIN32)
     set(HIDAPI_IMPL win/hid.c)
diff --git a/src/libslic3r/AABBTreeLines.hpp b/src/libslic3r/AABBTreeLines.hpp
index 55cf328f57..2a2efb504b 100644
--- a/src/libslic3r/AABBTreeLines.hpp
+++ b/src/libslic3r/AABBTreeLines.hpp
@@ -32,7 +32,9 @@ namespace AABBTreeLines {
             {
                 Vec<LineType::Dim, typename LineType::Scalar> nearest_point;
                 const LineType& line = lines[primitive_index];
-                squared_distance = line_alg::distance_to_squared(line, origin.template cast<typename LineType::Scalar>(), &nearest_point);
+                const Vec<LineType::Dim, typename LineType::Scalar> origin_cast =
+                    origin.template cast<typename LineType::Scalar>();
+                squared_distance = line_alg::distance_to_squared(line, origin_cast, &nearest_point);
                 return nearest_point.template cast<ScalarType>();
             }
         };
diff --git a/src/libslic3r/CMakeLists.txt b/src/libslic3r/CMakeLists.txt
index d85c65fd51..d6682734d2 100644
--- a/src/libslic3r/CMakeLists.txt
+++ b/src/libslic3r/CMakeLists.txt
@@ -20,6 +20,9 @@ endif()
 
 option(BUILD_SHARED_LIBS "Build shared libs" OFF)
 
+option(SLIC3R_WITH_OCCT "Enable OCCT CAD features" ON)
+option(SLIC3R_WITH_OPENCV "Enable OpenCV-powered color utilities" ON)
+
 set(lisbslic3r_sources
     AABBMesh.cpp
     AABBMesh.hpp
@@ -461,7 +464,7 @@ if (APPLE)
         )
 endif ()
 
-add_library(libslic3r STATIC ${lisbslic3r_sources} 
+add_library(libslic3r STATIC ${lisbslic3r_sources}
     "${CMAKE_CURRENT_BINARY_DIR}/libslic3r_version.h"
     ${OpenVDBUtils_SOURCES})
 source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${lisbslic3r_sources})
@@ -474,10 +477,12 @@ set(CGAL_DO_NOT_WARN_ABOUT_CMAKE_BUILD_TYPE ON CACHE BOOL "" FORCE)
 cmake_policy(PUSH)
 cmake_policy(SET CMP0011 NEW)
 find_package(CGAL REQUIRED)
-find_package(OpenCV REQUIRED core)
+if (SLIC3R_WITH_OPENCV)
+    find_package(OpenCV REQUIRED core)
+endif()
 cmake_policy(POP)
 
-add_library(libslic3r_cgal STATIC 
+add_library(libslic3r_cgal STATIC
     CutSurface.hpp CutSurface.cpp
     IntersectionPoints.hpp IntersectionPoints.cpp
     MeshBoolean.hpp MeshBoolean.cpp
@@ -515,59 +520,73 @@ target_include_directories(libslic3r PRIVATE ${CMAKE_CURRENT_SOURCE_DIR} PUBLIC
 target_include_directories(libslic3r SYSTEM PUBLIC ${EXPAT_INCLUDE_DIRS})
 
 # Find the OCCT and related libraries
-set(OpenCASCADE_DIR "${CMAKE_PREFIX_PATH}/lib/cmake/occt")
-find_package(OpenCASCADE REQUIRED)
-target_include_directories(libslic3r SYSTEM PUBLIC ${OpenCASCADE_INCLUDE_DIR})
-
-find_package(JPEG REQUIRED)
-
-set(OCCT_LIBS
-    TKXDESTEP
-    TKSTEP
-    TKSTEP209
-    TKSTEPAttr
-    TKSTEPBase
-    TKXCAF
-    TKXSBase
-    TKVCAF
-    TKCAF
-    TKLCAF
-    TKCDF
-    TKV3d
-    TKService
-    TKMesh
-    TKBO
-    TKPrim
-    TKHLR
-    TKShHealing
-    TKTopAlgo
-    TKGeomAlgo
-    TKBRep
-    TKGeomBase
-    TKG3d
-    TKG2d
-    TKMath
-    TKernel
-)
-
 find_package(libnoise REQUIRED)
+set(OCCT_PRIVATE_LIBS)
+
+if(SLIC3R_WITH_OCCT)
+    # Find the OCCT and related libraries
+    set(OpenCASCADE_DIR "${CMAKE_PREFIX_PATH}/lib/cmake/occt")
+    find_package(OpenCASCADE REQUIRED)
+    target_include_directories(libslic3r SYSTEM PUBLIC ${OpenCASCADE_INCLUDE_DIR})
+
+    find_package(JPEG REQUIRED)
+
+    set(OCCT_LIBS
+        TKXDESTEP
+        TKSTEP
+        TKSTEP209
+        TKSTEPAttr
+        TKSTEPBase
+        TKXCAF
+        TKXSBase
+        TKVCAF
+        TKCAF
+        TKLCAF
+        TKCDF
+        TKV3d
+        TKService
+        TKMesh
+        TKBO
+        TKPrim
+        TKHLR
+        TKShHealing
+        TKTopAlgo
+        TKGeomAlgo
+        TKBRep
+        TKGeomBase
+        TKG3d
+        TKG2d
+        TKMath
+        TKernel
+    )
+
+    list(APPEND OCCT_PRIVATE_LIBS ${OCCT_LIBS} JPEG::JPEG)
+
+    if(NOT WIN32)
+        # Link freetype for OCCT dependency (CAD operations need font rendering)
+        list(APPEND OCCT_PRIVATE_LIBS ${FREETYPE_LIBRARIES} OpenSSL::Crypto)
+        if (NOT APPLE)
+            list(APPEND OCCT_PRIVATE_LIBS fontconfig)
+        endif()
+    endif()
+else()
+    target_compile_definitions(libslic3r PUBLIC SLIC3R_NO_OCCT)
+endif()
+
 target_link_libraries(libslic3r
     PUBLIC
         admesh
         libigl
         libnest2d
         miniz
-        opencv_world
     PRIVATE
         ${CMAKE_DL_LIBS}
         ${EXPAT_LIBRARIES}
-        ${OCCT_LIBS}
         boost_libs
         cereal::cereal
         clipper
         eigen
         glu-libtess
-        JPEG::JPEG
         libslic3r_cgal
         mcut
         noise::noise
@@ -575,18 +594,19 @@ target_link_libraries(libslic3r
         qhull
         qoi
         semver
-        TBB::tbb
-        TBB::tbbmalloc
         ZLIB::ZLIB
+        ${OCCT_PRIVATE_LIBS}
     )
 
-if(NOT WIN32)
-    # Link freetype for OCCT dependency (CAD operations need font rendering)
-    target_link_libraries(libslic3r PRIVATE ${FREETYPE_LIBRARIES})
-    target_link_libraries(libslic3r PRIVATE OpenSSL::Crypto)
-    if (NOT APPLE)
-        target_link_libraries(libslic3r PRIVATE fontconfig)
-    endif()
+if (TBB_FOUND)
+    target_link_libraries(libslic3r PRIVATE TBB::tbb TBB::tbbmalloc)
+endif()
+
+if (SLIC3R_WITH_OPENCV)
+    target_link_libraries(libslic3r PUBLIC opencv_world)
+    target_compile_definitions(libslic3r PUBLIC SLIC3R_WITH_OPENCV=1)
+else()
+    target_compile_definitions(libslic3r PUBLIC SLIC3R_WITH_OPENCV=0)
 endif()
 
 if (APPLE)
diff --git a/src/libslic3r/ExtrusionEntity.hpp b/src/libslic3r/ExtrusionEntity.hpp
index edd7839cc1..a7e5689922 100644
--- a/src/libslic3r/ExtrusionEntity.hpp
+++ b/src/libslic3r/ExtrusionEntity.hpp
@@ -557,7 +557,7 @@ inline void extrusion_entities_append_paths_with_wipe(ExtrusionEntitiesPtr &dst,
                 Point temp = polyline.first_point() - last_end_point;
                 if (Vec2d(temp.x(), temp.y()).norm() <= 3 * scaled(width)) {
                     multi_path->paths.emplace_back(role, mm3_per_mm, width, height, true);
-                    multi_path->paths.back().polyline = std::move(Polyline(last_end_point, polyline.first_point()));
+                    multi_path->paths.back().polyline = Polyline(last_end_point, polyline.first_point());
                 } else {
                     dst.push_back(multi_path);
                     multi_path = new ExtrusionMultiPath();
diff --git a/src/libslic3r/Feature/FuzzySkin/FuzzySkin.cpp b/src/libslic3r/Feature/FuzzySkin/FuzzySkin.cpp
index 66fc90dc99..af7a61c80e 100644
--- a/src/libslic3r/Feature/FuzzySkin/FuzzySkin.cpp
+++ b/src/libslic3r/Feature/FuzzySkin/FuzzySkin.cpp
@@ -1,4 +1,7 @@
 #include <random>
+#ifndef __EMSCRIPTEN__
+#    include <thread>
+#endif
 
 #include "libslic3r/Algorithm/LineSplit.hpp"
 #include "libslic3r/Arachne/utils/ExtrusionJunction.hpp"
@@ -21,10 +24,16 @@ using namespace Slic3r;
 namespace Slic3r::Feature::FuzzySkin {
 
 // Produces a random value between 0 and 1. Thread-safe.
-static double random_value() {
+static double random_value()
+{
     thread_local std::random_device rd;
-    // Hash thread ID for random number seed if no hardware rng seed is available
+#ifndef __EMSCRIPTEN__
+    // Hash thread ID for random number seed if no hardware rng seed is available.
     thread_local std::mt19937 gen(rd.entropy() > 0 ? rd() : std::hash<std::thread::id>()(std::this_thread::get_id()));
+#else
+    // Emscripten builds are effectively single-threaded, fall back to device entropy.
+    thread_local std::mt19937 gen(rd());
+#endif
     thread_local std::uniform_real_distribution<double> dist(0.0, 1.0);
     return dist(gen);
 }
diff --git a/src/libslic3r/Feature/Interlocking/InterlockingGenerator.hpp b/src/libslic3r/Feature/Interlocking/InterlockingGenerator.hpp
index 6f331fb8ef..3ba7432a49 100644
--- a/src/libslic3r/Feature/Interlocking/InterlockingGenerator.hpp
+++ b/src/libslic3r/Feature/Interlocking/InterlockingGenerator.hpp
@@ -7,6 +7,8 @@
 #include "libslic3r/Print.hpp"
 #include "VoxelUtils.hpp"
 
+#include <unordered_set>
+
 namespace Slic3r {
 
 /*!
diff --git a/src/libslic3r/Fill/Fill.cpp b/src/libslic3r/Fill/Fill.cpp
index e8294ea673..4abe7345f2 100644
--- a/src/libslic3r/Fill/Fill.cpp
+++ b/src/libslic3r/Fill/Fill.cpp
@@ -1,6 +1,7 @@
 #include <assert.h>
 #include <stdio.h>
 #include <memory>
+#include <unordered_set>
 
 #include "../ClipperUtils.hpp"
 #include "../Geometry.hpp"
diff --git a/src/libslic3r/Fill/FillAdaptive.cpp b/src/libslic3r/Fill/FillAdaptive.cpp
index 3ec9ec3685..3bee953ecb 100644
--- a/src/libslic3r/Fill/FillAdaptive.cpp
+++ b/src/libslic3r/Fill/FillAdaptive.cpp
@@ -1393,8 +1393,8 @@ void Filler::_fill_surface_single(
     }
 #endif /* ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT */
 
-    const auto hook_length     = coordf_t(std::min<float>(std::numeric_limits<coord_t>::max(), scale_(params.anchor_length)));
-    const auto hook_length_max = coordf_t(std::min<float>(std::numeric_limits<coord_t>::max(), scale_(params.anchor_length_max)));
+    const auto hook_length     = coordf_t(std::min<coordf_t>(static_cast<coordf_t>(std::numeric_limits<coord_t>::max()), scale_(params.anchor_length)));
+    const auto hook_length_max = coordf_t(std::min<coordf_t>(static_cast<coordf_t>(std::numeric_limits<coord_t>::max()), scale_(params.anchor_length_max)));
 
     Polylines all_polylines_with_hooks = all_polylines.size() > 1 ? connect_lines_using_hooks(std::move(all_polylines), expolygon, this->spacing, hook_length, hook_length_max) : std::move(all_polylines);
 
diff --git a/src/libslic3r/Format/STEP.cpp b/src/libslic3r/Format/STEP.cpp
index 5105d26776..669ebd44f6 100644
--- a/src/libslic3r/Format/STEP.cpp
+++ b/src/libslic3r/Format/STEP.cpp
@@ -4,6 +4,81 @@
 
 #include "STEP.hpp"
 
+#ifdef SLIC3R_NO_OCCT
+
+#include <string>
+#include <utility>
+
+namespace Slic3r {
+
+bool StepPreProcessor::preprocess(const char* path, std::string &output_path)
+{
+    output_path = path ? std::string(path) : std::string();
+    return true;
+}
+
+bool StepPreProcessor::isUtf8File(const char* /*path*/)
+{
+    return true;
+}
+
+bool StepPreProcessor::isUtf8(const std::string /*str*/)
+{
+    return true;
+}
+
+Step::Step(fs::path path, ImportStepProgressFn stepFn, StepIsUtf8Fn isUtf8Fn)
+    : Step(std::move(path.string()), std::move(stepFn), std::move(isUtf8Fn))
+{
+}
+
+Step::Step(std::string path, ImportStepProgressFn stepFn, StepIsUtf8Fn isUtf8Fn)
+    : m_path(std::move(path))
+    , m_stepFn(std::move(stepFn))
+    , m_utf8Fn(std::move(isUtf8Fn))
+{
+}
+
+bool Step::load()
+{
+    return false;
+}
+
+unsigned int Step::get_triangle_num(double /*linear_defletion*/, double /*angle_defletion*/)
+{
+    return 0;
+}
+
+unsigned int Step::get_triangle_num_tbb(double /*linear_defletion*/, double /*angle_defletion*/)
+{
+    return 0;
+}
+
+void Step::clean_mesh_data()
+{
+}
+
+bool load_step(const char * /*path*/, Model * /*model*/, bool& is_cancel,
+               double /*linear_defletion*/, double /*angle_defletion*/,
+               bool /*isSplitCompound*/, ImportStepProgressFn proFn,
+               StepIsUtf8Fn /*isUtf8Fn*/, long& mesh_face_num)
+{
+    if (proFn) {
+        bool dummy_cancel = false;
+        proFn(LOAD_STEP_STAGE_READ_FILE, 0, 1, dummy_cancel);
+        proFn(LOAD_STEP_STAGE_GET_SOLID, 0, 0, dummy_cancel);
+        proFn(LOAD_STEP_STAGE_GET_MESH, 0, 0, dummy_cancel);
+    }
+
+    is_cancel = false;
+    mesh_face_num = 0;
+    return false;
+}
+
+} // namespace Slic3r
+
+#else
+
 #include <string>
 #include <boost/nowide/cstdio.hpp>
 #include <boost/nowide/iostream.hpp>
@@ -518,3 +593,5 @@ unsigned int Step::get_triangle_num_tbb(double linear_defletion, double angle_de
 }
 
 }; // namespace Slic3r
+
+#endif // SLIC3R_NO_OCCT
diff --git a/src/libslic3r/Format/STEP.hpp b/src/libslic3r/Format/STEP.hpp
index 85c8f655ef..8142e94c30 100644
--- a/src/libslic3r/Format/STEP.hpp
+++ b/src/libslic3r/Format/STEP.hpp
@@ -1,18 +1,26 @@
 #ifndef slic3r_Format_STEP_hpp_
 #define slic3r_Format_STEP_hpp_
+#include <atomic>
+#include <functional>
+#include <string>
+#include <vector>
+
+#include <boost/filesystem/path.hpp>
+#include <boost/filesystem.hpp>
+
+#ifndef SLIC3R_NO_OCCT
 #include "XCAFDoc_DocumentTool.hxx"
 #include "XCAFApp_Application.hxx"
 #include "XCAFDoc_ShapeTool.hxx"
-#include <boost/filesystem/path.hpp>
-#include <boost/filesystem.hpp>
 #include <Message_ProgressIndicator.hxx>
-#include <atomic>
+#endif
 
 namespace fs = boost::filesystem;
 
 namespace Slic3r {
 
 class TriangleMesh;
+class Model;
 class ModelObject;
 
 // load step stage
@@ -25,6 +33,8 @@ const int LOAD_STEP_STAGE_UNIT_NUM           = 5;
 typedef std::function<void(int load_stage, int current, int total, bool& cancel)> ImportStepProgressFn;
 typedef std::function<void(bool isUtf8)> StepIsUtf8Fn;
 
+#ifndef SLIC3R_NO_OCCT
+
 struct NamedSolid
 {
     NamedSolid(const TopoDS_Shape& s,
@@ -105,6 +115,34 @@ private:
     std::vector<NamedSolid> m_name_solids;
 };
 
+#else // SLIC3R_NO_OCCT
+
+class StepPreProcessor {
+public:
+    bool preprocess(const char* path, std::string &output_path);
+    static bool isUtf8File(const char* path);
+    static bool isUtf8(const std::string str);
+};
+
+class Step
+{
+public:
+    Step(fs::path path, ImportStepProgressFn stepFn = nullptr, StepIsUtf8Fn isUtf8Fn = nullptr);
+    Step(std::string path, ImportStepProgressFn stepFn = nullptr, StepIsUtf8Fn isUtf8Fn = nullptr);
+    bool load();
+    unsigned int get_triangle_num(double linear_defletion, double angle_defletion);
+    unsigned int get_triangle_num_tbb(double linear_defletion, double angle_defletion);
+    void clean_mesh_data();
+
+    std::atomic<bool> m_stop_mesh{false};
+private:
+    std::string m_path;
+    ImportStepProgressFn m_stepFn;
+    StepIsUtf8Fn m_utf8Fn;
+};
+
+#endif // SLIC3R_NO_OCCT
+
 }; // namespace Slic3r
 
 #endif /* slic3r_Format_STEP_hpp_ */
diff --git a/src/libslic3r/Format/svg.cpp b/src/libslic3r/Format/svg.cpp
index 4a96274b99..43d64bfb81 100644
--- a/src/libslic3r/Format/svg.cpp
+++ b/src/libslic3r/Format/svg.cpp
@@ -9,6 +9,7 @@
 
 #include <boost/log/trivial.hpp>
 
+#ifndef SLIC3R_NO_OCCT
 #include "BRepBuilderAPI_MakeWire.hxx"
 #include "BRepBuilderAPI_MakeEdge.hxx"
 #include "BRepBuilderAPI_MakeFace.hxx"
@@ -20,6 +21,9 @@
 #include "TopoDS.hxx"
 #include "BRepExtrema_SelfIntersection.hxx"
 #include "clipper/clipper.hpp"
+#endif
+
+#ifndef SLIC3R_NO_OCCT
 
 using namespace ClipperLib;
 
@@ -400,3 +404,17 @@ bool load_svg(const char *path, Model *model, std::string &message)
     return true;
 }
 } // namespace Slic3r
+
+#else // SLIC3R_NO_OCCT
+
+namespace Slic3r {
+
+bool load_svg(const char * /*path*/, Model * /*model*/, std::string &message)
+{
+    message = "SVG import is not available in this build.";
+    return false;
+}
+
+} // namespace Slic3r
+
+#endif // SLIC3R_NO_OCCT
diff --git a/src/libslic3r/GCode.cpp b/src/libslic3r/GCode.cpp
index dda1d0c5ed..c341463d12 100644
--- a/src/libslic3r/GCode.cpp
+++ b/src/libslic3r/GCode.cpp
@@ -2758,6 +2758,78 @@ void GCode::process_layers(
     const std::vector<std::pair<coordf_t, std::vector<LayerToPrint>>>   &layers_to_print,
     GCodeOutputStream                                                   &output_stream)
 {
+    if (m_spiral_vase) {
+        float nozzle_diameter  = EXTRUDER_CONFIG(nozzle_diameter);
+        float max_xy_smoothing = m_config.get_abs_value("spiral_mode_max_xy_smoothing", nozzle_diameter);
+        this->m_spiral_vase->set_max_xy_smoothing(max_xy_smoothing);
+    }
+
+#ifdef __EMSCRIPTEN__
+    const bool has_spiral = static_cast<bool>(m_spiral_vase);
+    const bool has_pressure_equalizer = static_cast<bool>(m_pressure_equalizer);
+    const bool has_fan_mover = (config().fan_speedup_time.value != 0 || config().fan_kickstart.value > 0);
+
+    auto process_result = [&](LayerResult result) {
+        if (has_spiral && !result.nop_layer_result) {
+            auto &spiral = *m_spiral_vase;
+            spiral.enable(result.spiral_vase_enable);
+            bool last_layer = (result.layer_id == layers_to_print.size() - 1);
+            result.gcode = spiral.process_layer(std::move(result.gcode), last_layer);
+        }
+
+        if (has_pressure_equalizer) {
+            result = m_pressure_equalizer->process_layer(std::move(result));
+        }
+
+        std::string gcode_chunk;
+        if (result.nop_layer_result) {
+            gcode_chunk = std::move(result.gcode);
+        } else {
+            gcode_chunk = m_cooling_buffer->process_layer(std::move(result.gcode), result.layer_id, result.cooling_buffer_flush);
+        }
+
+        if (has_fan_mover) {
+            CNumericLocalesSetter locales_setter;
+            if (m_fan_mover.get() == nullptr) {
+                m_fan_mover.reset(new Slic3r::FanMover(
+                    m_writer,
+                    std::abs((float)config().fan_speedup_time.value),
+                    config().fan_speedup_time.value > 0,
+                    config().use_relative_e_distances.value,
+                    config().fan_speedup_overhangs.value,
+                    (float)config().fan_kickstart.value));
+            }
+            gcode_chunk = m_fan_mover->process_gcode(std::move(gcode_chunk), true);
+        }
+
+        if (!has_spiral && !gcode_chunk.empty()) {
+            gcode_chunk = m_pa_processor->process_layer(std::move(gcode_chunk));
+        } else if (!has_spiral) {
+            gcode_chunk = m_pa_processor->process_layer(std::move(gcode_chunk));
+        }
+
+        if (!gcode_chunk.empty())
+            output_stream.write(gcode_chunk);
+    };
+
+    const size_t flush_layers = has_pressure_equalizer ? 1 : 0;
+    for (size_t layer_idx = 0; layer_idx < layers_to_print.size() + flush_layers; ++layer_idx) {
+        LayerResult result;
+        if (layer_idx >= layers_to_print.size()) {
+            result = LayerResult::make_nop_layer_result();
+        } else {
+            const auto &layer = layers_to_print[layer_idx];
+            const LayerTools &layer_tools = tool_ordering.tools_for_layer(layer.first);
+            print.set_status(80, Slic3r::format(_(L("Generating G-code: layer %1%")), std::to_string(layer_idx + 1)));
+            if (m_wipe_tower && layer_tools.has_wipe_tower)
+                m_wipe_tower->next_layer();
+            check_placeholder_parser_failed();
+            print.throw_if_canceled();
+            result = this->process_layer(print, layer.second, layer_tools, &layer == &layers_to_print.back(), &print_object_instances_ordering, size_t(-1));
+        }
+        process_result(std::move(result));
+    }
+#else
     // The pipeline is variable: The vase mode filter is optional.
     size_t layer_to_print_idx = 0;
     const auto generator = tbb::make_filter<void, LayerResult>(slic3r_tbb_filtermode::serial_in_order,
@@ -2767,8 +2839,6 @@ void GCode::process_layers(
                     fc.stop();
                     return {};
                 } else {
-                    // Pressure equalizer need insert empty input. Because it returns one layer back.
-                    // Insert NOP (no operation) layer;
                     ++layer_to_print_idx;
                     return LayerResult::make_nop_layer_result();
                 }
@@ -2778,22 +2848,16 @@ void GCode::process_layers(
                 print.set_status(80, Slic3r::format(_(L("Generating G-code: layer %1%")), std::to_string(layer_to_print_idx)));
                 if (m_wipe_tower && layer_tools.has_wipe_tower)
                     m_wipe_tower->next_layer();
-                //BBS
                 check_placeholder_parser_failed();
                 print.throw_if_canceled();
                 return this->process_layer(print, layer.second, layer_tools, &layer == &layers_to_print.back(), &print_object_instances_ordering, size_t(-1));
             }
         });
-    if (m_spiral_vase) {
-        float nozzle_diameter  = EXTRUDER_CONFIG(nozzle_diameter);
-        float max_xy_smoothing = m_config.get_abs_value("spiral_mode_max_xy_smoothing", nozzle_diameter);
-        this->m_spiral_vase->set_max_xy_smoothing(max_xy_smoothing);
-    }
     const auto spiral_mode = tbb::make_filter<LayerResult, LayerResult>(slic3r_tbb_filtermode::serial_in_order,
         [&spiral_mode = *this->m_spiral_vase.get(), &layers_to_print](LayerResult in) -> LayerResult {
-        	if (in.nop_layer_result)
+	if (in.nop_layer_result)
                 return in;
-                
+
             spiral_mode.enable(in.spiral_vase_enable);
             bool last_layer = in.layer_id == layers_to_print.size() - 1;
             return { spiral_mode.process_layer(std::move(in.gcode), last_layer), in.layer_id, in.spiral_vase_enable, in.cooling_buffer_flush};
@@ -2804,7 +2868,7 @@ void GCode::process_layers(
         });
     const auto cooling = tbb::make_filter<LayerResult, std::string>(slic3r_tbb_filtermode::serial_in_order,
         [&cooling_buffer = *this->m_cooling_buffer.get()](LayerResult in) -> std::string {
-        	if (in.nop_layer_result)
+	if (in.nop_layer_result)
                 return in.gcode;
             return cooling_buffer.process_layer(std::move(in.gcode), in.layer_id, in.cooling_buffer_flush);
         });
@@ -2813,7 +2877,7 @@ void GCode::process_layers(
                 return pa_processor.process_layer(std::move(in));
             }
         );
-    
+
     const auto output = tbb::make_filter<std::string, void>(slic3r_tbb_filtermode::serial_in_order,
         [&output_stream](std::string s) { output_stream.write(s); }
     );
@@ -2832,21 +2896,20 @@ void GCode::process_layers(
                     config.use_relative_e_distances.value,
                     config.fan_speedup_overhangs.value,
                     (float)config.fan_kickstart.value));
-            //flush as it's a whole layer
             return fan_mover->process_gcode(in, true);
         }
         return in;
     });
 
-    // The pipeline elements are joined using const references, thus no copying is performed.
     if (m_spiral_vase && m_pressure_equalizer)
         tbb::parallel_pipeline(12, generator & spiral_mode & pressure_equalizer & cooling & fan_mover & output);
     else if (m_spiral_vase)
-    	tbb::parallel_pipeline(12, generator & spiral_mode & cooling & fan_mover & output);
+	tbb::parallel_pipeline(12, generator & spiral_mode & cooling & fan_mover & output);
     else if	(m_pressure_equalizer)
         tbb::parallel_pipeline(12, generator & pressure_equalizer & cooling & fan_mover & pa_processor_filter & output);
     else
-    	tbb::parallel_pipeline(12, generator & cooling & fan_mover & pa_processor_filter & output);
+	tbb::parallel_pipeline(12, generator & cooling & fan_mover & pa_processor_filter & output);
+#endif
 }
 
 // Process all layers of a single object instance (sequential mode) with a parallel pipeline:
@@ -2861,7 +2924,73 @@ void GCode::process_layers(
     // BBS
     const bool                               prime_extruder)
 {
-    // The pipeline is variable: The vase mode filter is optional.
+#ifdef __EMSCRIPTEN__
+    const bool has_spiral = static_cast<bool>(m_spiral_vase);
+    const bool has_pressure_equalizer = static_cast<bool>(m_pressure_equalizer);
+    const bool has_fan_mover = (config().fan_speedup_time.value != 0 || config().fan_kickstart.value > 0);
+
+    if (m_spiral_vase) {
+        float nozzle_diameter  = EXTRUDER_CONFIG(nozzle_diameter);
+        float max_xy_smoothing = m_config.get_abs_value("spiral_mode_max_xy_smoothing", nozzle_diameter);
+        this->m_spiral_vase->set_max_xy_smoothing(max_xy_smoothing);
+    }
+
+    auto process_result = [&](LayerResult result, size_t last_layer_idx) {
+        if (has_spiral && !result.nop_layer_result) {
+            auto &spiral = *m_spiral_vase;
+            spiral.enable(result.spiral_vase_enable);
+            bool last_layer = (result.layer_id == last_layer_idx);
+            result.gcode = spiral.process_layer(std::move(result.gcode), last_layer);
+        }
+
+        if (has_pressure_equalizer) {
+            result = m_pressure_equalizer->process_layer(std::move(result));
+        }
+
+        std::string gcode_chunk;
+        if (result.nop_layer_result) {
+            gcode_chunk = std::move(result.gcode);
+        } else {
+            gcode_chunk = m_cooling_buffer->process_layer(std::move(result.gcode), result.layer_id, result.cooling_buffer_flush);
+        }
+
+        if (has_fan_mover) {
+            if (m_fan_mover.get() == nullptr) {
+                m_fan_mover.reset(new Slic3r::FanMover(
+                    m_writer,
+                    std::abs((float)config().fan_speedup_time.value),
+                    config().fan_speedup_time.value > 0,
+                    config().use_relative_e_distances.value,
+                    config().fan_speedup_overhangs.value,
+                    (float)config().fan_kickstart.value));
+            }
+            gcode_chunk = m_fan_mover->process_gcode(std::move(gcode_chunk), true);
+        }
+
+        if (!has_spiral) {
+            gcode_chunk = m_pa_processor->process_layer(std::move(gcode_chunk));
+        }
+
+        if (!gcode_chunk.empty())
+            output_stream.write(gcode_chunk);
+    };
+
+    const size_t flush_layers = has_pressure_equalizer ? 1 : 0;
+    const size_t last_real_layer = layers_to_print.empty() ? 0 : layers_to_print.size() - 1;
+    for (size_t idx = 0; idx < layers_to_print.size() + flush_layers; ++idx) {
+        LayerResult result;
+        if (idx >= layers_to_print.size()) {
+            result = LayerResult::make_nop_layer_result();
+        } else {
+            LayerToPrint &layer = layers_to_print[idx];
+            print.set_status(80, Slic3r::format(_(L("Generating G-code: layer %1%")), std::to_string(idx + 1)));
+            check_placeholder_parser_failed();
+            print.throw_if_canceled();
+            result = this->process_layer(print, { std::move(layer) }, tool_ordering.tools_for_layer(layer.print_z()), &layer == &layers_to_print.back(), nullptr, single_object_idx, prime_extruder);
+        }
+        process_result(std::move(result), last_real_layer);
+    }
+#else
     size_t layer_to_print_idx = 0;
     const auto generator = tbb::make_filter<void, LayerResult>(slic3r_tbb_filtermode::serial_in_order,
         [this, &print, &tool_ordering, &layers_to_print, &layer_to_print_idx, single_object_idx, prime_extruder](tbb::flow_control& fc) -> LayerResult {
@@ -2870,15 +2999,12 @@ void GCode::process_layers(
                     fc.stop();
                     return {};
                 } else {
-                    // Pressure equalizer need insert empty input. Because it returns one layer back.
-                    // Insert NOP (no operation) layer;
                     ++layer_to_print_idx;
                     return LayerResult::make_nop_layer_result();
                 }
             } else {
                 LayerToPrint &layer = layers_to_print[layer_to_print_idx ++];
                 print.set_status(80, Slic3r::format(_(L("Generating G-code: layer %1%")), std::to_string(layer_to_print_idx)));
-                //BBS
                 check_placeholder_parser_failed();
                 print.throw_if_canceled();
                 return this->process_layer(print, { std::move(layer) }, tool_ordering.tools_for_layer(layer.print_z()), &layer == &layers_to_print.back(), nullptr, single_object_idx, prime_extruder);
@@ -2912,7 +3038,7 @@ void GCode::process_layers(
             return pa_processor.process_layer(std::move(in));
         }
     );
-    
+
     const auto output = tbb::make_filter<std::string, void>(slic3r_tbb_filtermode::serial_in_order,
         [&output_stream](std::string s) { output_stream.write(s); }
     );
@@ -2929,21 +3055,20 @@ void GCode::process_layers(
                     config.use_relative_e_distances.value,
                     config.fan_speedup_overhangs.value,
                     (float)config.fan_kickstart.value));
-            //flush as it's a whole layer
             return fan_mover->process_gcode(in, true);
         }
         return in;
     });
 
-    // The pipeline elements are joined using const references, thus no copying is performed.
     if (m_spiral_vase && m_pressure_equalizer)
         tbb::parallel_pipeline(12, generator & spiral_mode & pressure_equalizer & cooling & fan_mover & output);
     else if (m_spiral_vase)
-    	tbb::parallel_pipeline(12, generator & spiral_mode & cooling & fan_mover & output);
+	tbb::parallel_pipeline(12, generator & spiral_mode & cooling & fan_mover & output);
     else if	(m_pressure_equalizer)
         tbb::parallel_pipeline(12, generator & pressure_equalizer & cooling & fan_mover & pa_processor_filter & output);
     else
-    	tbb::parallel_pipeline(12, generator & cooling & fan_mover & pa_processor_filter & output);
+	tbb::parallel_pipeline(12, generator & cooling & fan_mover & pa_processor_filter & output);
+#endif
 }
 
 std::string GCode::placeholder_parser_process(const std::string &name, const std::string &templ, unsigned int current_extruder_id, const DynamicConfig *config_override)
diff --git a/src/libslic3r/GCode.hpp b/src/libslic3r/GCode.hpp
index f3ce7aaf74..d6b7ef5953 100644
--- a/src/libslic3r/GCode.hpp
+++ b/src/libslic3r/GCode.hpp
@@ -156,7 +156,7 @@ struct LayerResult {
     // It is used for the pressure equalizer because it needs to buffer one layer back.
     bool        nop_layer_result { false };
 
-    static LayerResult make_nop_layer_result() { return {"", std::numeric_limits<coord_t>::max(), false, false, true}; }
+    static LayerResult make_nop_layer_result() { return {"", std::numeric_limits<size_t>::max(), false, false, true}; }
 };
 
 class GCode {
diff --git a/src/libslic3r/GCode/ToolOrdering.cpp b/src/libslic3r/GCode/ToolOrdering.cpp
index debdb863d0..73fbc0f6f8 100644
--- a/src/libslic3r/GCode/ToolOrdering.cpp
+++ b/src/libslic3r/GCode/ToolOrdering.cpp
@@ -43,7 +43,7 @@ static std::vector<unsigned int> solve_extruder_order(const std::vector<std::vec
 
     unsigned int iterations = (1 << all_extruders.size());
     unsigned int final_state = iterations - 1;
-    std::vector<std::vector<float>>cache(iterations, std::vector<float>(all_extruders.size(),0x7fffffff));
+    std::vector<std::vector<float>> cache(iterations, std::vector<float>(all_extruders.size(), std::numeric_limits<float>::max()));
     std::vector<std::vector<int>>prev(iterations, std::vector<int>(all_extruders.size(), -1));
     cache[1][0] = 0.;
     for (unsigned int state = 0; state < iterations; ++state) {
@@ -70,7 +70,7 @@ static std::vector<unsigned int> solve_extruder_order(const std::vector<std::vec
     for (unsigned int dst = 0; dst < all_extruders.size(); ++dst) {
         if (all_extruders[dst] != start_extruder_id && cost > cache[final_state][dst]) {
             cost = cache[final_state][dst];
-            final_dst = dst;
+            final_dst = static_cast<int>(dst);
         }
     }
 
diff --git a/src/libslic3r/Geometry/VoronoiUtilsCgal.cpp b/src/libslic3r/Geometry/VoronoiUtilsCgal.cpp
index 28a648851d..ad08dbfc6e 100644
--- a/src/libslic3r/Geometry/VoronoiUtilsCgal.cpp
+++ b/src/libslic3r/Geometry/VoronoiUtilsCgal.cpp
@@ -1,11 +1,7 @@
-// Needed since the CGAL headers are not self-contained.
-#include <boost/next_prior.hpp>
-#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
-#include <CGAL/Arr_segment_traits_2.h>
-#include <CGAL/Surface_sweep_2_algorithms.h>
-#include <boost/variant/get.hpp>
 #include <vector>
 #include <cassert>
+#include <boost/next_prior.hpp>
+#include <boost/variant/get.hpp>
 
 #include "libslic3r/Geometry/Voronoi.hpp"
 #include "libslic3r/Geometry/VoronoiUtils.hpp"
@@ -15,6 +11,45 @@
 #include "libslic3r/Line.hpp"
 #include "libslic3r/Point.hpp"
 
+#ifdef __EMSCRIPTEN__
+
+using VD = Slic3r::Geometry::VoronoiDiagram;
+
+namespace Slic3r::Geometry {
+
+bool VoronoiUtilsCgal::is_voronoi_diagram_planar_intersection(const VD &)
+{
+    return true;
+}
+
+template<typename SegmentIterator>
+typename boost::polygon::enable_if<
+    typename boost::polygon::gtl_if<typename boost::polygon::is_segment_concept<
+        typename boost::polygon::geometry_concept<typename std::iterator_traits<SegmentIterator>::value_type>::type>::type>::type,
+    bool>::type
+VoronoiUtilsCgal::is_voronoi_diagram_planar_angle(const VD &, SegmentIterator, SegmentIterator)
+{
+    return true;
+}
+
+using PolygonsSegmentIndexConstIt = std::vector<Arachne::PolygonsSegmentIndex>::const_iterator;
+using LinesIt                     = Lines::iterator;
+using ColoredLinesConstIt         = ColoredLines::const_iterator;
+
+// Explicit template instantiation (no-op for WASM).
+template bool VoronoiUtilsCgal::is_voronoi_diagram_planar_angle(const VD &, LinesIt, LinesIt);
+template bool VoronoiUtilsCgal::is_voronoi_diagram_planar_angle(const VD &, VD::SegmentIt, VD::SegmentIt);
+template bool VoronoiUtilsCgal::is_voronoi_diagram_planar_angle(const VD &, ColoredLinesConstIt, ColoredLinesConstIt);
+template bool VoronoiUtilsCgal::is_voronoi_diagram_planar_angle(const VD &, PolygonsSegmentIndexConstIt, PolygonsSegmentIndexConstIt);
+
+} // namespace Slic3r::Geometry
+
+#else
+
+#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
+#include <CGAL/Arr_segment_traits_2.h>
+#include <CGAL/Surface_sweep_2_algorithms.h>
+
 namespace CGAL {
 class MP_Float;
 }  // namespace CGAL
@@ -332,3 +367,5 @@ VoronoiUtilsCgal::is_voronoi_diagram_planar_angle(const VD             &voronoi_
 }
 
 } // namespace Slic3r::Geometry
+
+#endif // __EMSCRIPTEN__
diff --git a/src/libslic3r/LocalesUtils.cpp b/src/libslic3r/LocalesUtils.cpp
index d321072335..5379b53e34 100644
--- a/src/libslic3r/LocalesUtils.cpp
+++ b/src/libslic3r/LocalesUtils.cpp
@@ -3,6 +3,7 @@
 #ifdef _WIN32
     #include <charconv>
 #endif
+#include <sstream>
 #include <stdexcept>
 
 #include <fast_float/fast_float.h>
diff --git a/src/libslic3r/Model.cpp b/src/libslic3r/Model.cpp
index 4edec076af..f7908b2170 100644
--- a/src/libslic3r/Model.cpp
+++ b/src/libslic3r/Model.cpp
@@ -177,6 +177,7 @@ Model::~Model()
         Slic3r::remove_backup(*this, true);
 }
 
+#ifndef SLIC3R_NO_OCCT
 Model Model::read_from_step(const std::string&                                      input_file,
                             LoadStrategy                                            options,
                             ImportStepProgressFn                                    stepFn,
@@ -222,6 +223,19 @@ Model Model::read_from_step(const std::string&
 
     return model;
 }
+#else
+Model Model::read_from_step(const std::string&                                      input_file,
+                            LoadStrategy                                            /*options*/,
+                            ImportStepProgressFn                                    /*stepFn*/,
+                            StepIsUtf8Fn                                            /*stepIsUtf8Fn*/,
+                            std::function<int(Slic3r::Step&, double&, double&, bool&)>     /*step_mesh_fn*/,
+                            double                                                  /*linear_defletion*/,
+                            double                                                  /*angle_defletion*/,
+                            bool                                                   /*is_split_compound*/)
+{
+    throw Slic3r::RuntimeError(_L("STEP support is not available in this build."));
+}
+#endif
 
 // BBS: add part plate related logic
 // BBS: backup & restore
diff --git a/src/libslic3r/MultiPoint.hpp b/src/libslic3r/MultiPoint.hpp
index 0dfb98f4b4..9030703d06 100644
--- a/src/libslic3r/MultiPoint.hpp
+++ b/src/libslic3r/MultiPoint.hpp
@@ -22,6 +22,7 @@ public:
     MultiPoint(MultiPoint &&other) : points(std::move(other.points)) {}
     MultiPoint(std::initializer_list<Point> list) : points(list) {}
     explicit MultiPoint(const Points &_points) : points(_points) {}
+    virtual ~MultiPoint() = default;
     MultiPoint& operator=(const MultiPoint &other) { points = other.points; return *this; }
     MultiPoint& operator=(MultiPoint &&other) { points = std::move(other.points); return *this; }
     void scale(double factor);
@@ -119,6 +120,8 @@ class MultiPoint3
 public:
     Points3 points;
 
+    virtual ~MultiPoint3() = default;
+
     void append(const Vec3crd& point) { this->points.push_back(point); }
 
     void translate(double x, double y);
diff --git a/src/libslic3r/OpenVDBUtils.cpp b/src/libslic3r/OpenVDBUtils.cpp
index 72c7668a45..ad77a8511e 100644
--- a/src/libslic3r/OpenVDBUtils.cpp
+++ b/src/libslic3r/OpenVDBUtils.cpp
@@ -1,6 +1,29 @@
 #define NOMINMAX
 #include "OpenVDBUtils.hpp"
 
+#if defined(__EMSCRIPTEN__) && defined(ORCA_DISABLE_OPENVDB)
+
+namespace Slic3r {
+
+openvdb::FloatGrid::Ptr mesh_to_grid(const indexed_triangle_set &, const openvdb::math::Transform &, float, float, float, int)
+{
+    return {};
+}
+
+indexed_triangle_set grid_to_mesh(const openvdb::FloatGrid &, double, double, bool)
+{
+    return {};
+}
+
+openvdb::FloatGrid::Ptr redistance_grid(const openvdb::FloatGrid &, double, double, double)
+{
+    return {};
+}
+
+} // namespace Slic3r
+
+#else
+
 #ifdef _MSC_VER
 // Suppress warning C4146 in OpenVDB: unary minus operator applied to unsigned type, result still unsigned 
 #pragma warning(push)
@@ -134,3 +157,5 @@ openvdb::FloatGrid::Ptr redistance_grid(const openvdb::FloatGrid &grid,
 }
 
 } // namespace Slic3r
+
+#endif // defined(__EMSCRIPTEN__) && defined(ORCA_DISABLE_OPENVDB)
diff --git a/src/libslic3r/OpenVDBUtils.hpp b/src/libslic3r/OpenVDBUtils.hpp
index f4441ba964..5c439eef6d 100644
--- a/src/libslic3r/OpenVDBUtils.hpp
+++ b/src/libslic3r/OpenVDBUtils.hpp
@@ -3,6 +3,45 @@
 
 #include <libslic3r/TriangleMesh.hpp>
 
+#if defined(__EMSCRIPTEN__) && defined(ORCA_DISABLE_OPENVDB)
+
+#include <memory>
+
+namespace openvdb {
+class FloatGrid {
+public:
+    using Ptr = std::shared_ptr<FloatGrid>;
+};
+
+namespace math {
+struct Transform {};
+} // namespace math
+
+} // namespace openvdb
+
+namespace Slic3r {
+
+openvdb::FloatGrid::Ptr mesh_to_grid(const indexed_triangle_set &    mesh,
+                                     const openvdb::math::Transform &tr = {},
+                                     float voxel_scale                  = 1.f,
+                                     float exteriorBandWidth = 3.0f,
+                                     float interiorBandWidth = 3.0f,
+                                     int   flags             = 0);
+
+indexed_triangle_set grid_to_mesh(const openvdb::FloatGrid &grid,
+                                  double                    isovalue   = 0.0,
+                                  double                    adaptivity = 0.0,
+                                  bool relaxDisorientedTriangles = true);
+
+openvdb::FloatGrid::Ptr redistance_grid(const openvdb::FloatGrid &grid,
+                                        double                    iso,
+                                        double ext_range = 3.,
+                                        double int_range = 3.);
+
+} // namespace Slic3r
+
+#else // defined(__EMSCRIPTEN__) && defined(ORCA_DISABLE_OPENVDB)
+
 #ifdef _MSC_VER
 // Suppress warning C4146 in include/gmp.h(2177,31): unary minus operator applied to unsigned type, result still unsigned 
 #pragma warning(push)
@@ -45,4 +84,8 @@ openvdb::FloatGrid::Ptr redistance_grid(const openvdb::FloatGrid &grid,
 
 } // namespace Slic3r
 
+#endif // defined(__EMSCRIPTEN__) && defined(ORCA_DISABLE_OPENVDB)
+
 #endif // OPENVDBUTILS_HPP
+
+
diff --git a/src/libslic3r/PNGReadWrite.cpp b/src/libslic3r/PNGReadWrite.cpp
index 32b9a8f79e..023a78f1f0 100644
--- a/src/libslic3r/PNGReadWrite.cpp
+++ b/src/libslic3r/PNGReadWrite.cpp
@@ -2,6 +2,7 @@
 
 #include <memory>
 
+#include <cassert>
 #include <cstdio>
 #include <png.h>
 
diff --git a/src/libslic3r/Platform.cpp b/src/libslic3r/Platform.cpp
index 338752112b..1f1e09a3e7 100644
--- a/src/libslic3r/Platform.cpp
+++ b/src/libslic3r/Platform.cpp
@@ -55,6 +55,10 @@ void detect_platform()
             }
         }
     }
+#elif defined(__EMSCRIPTEN__)
+    BOOST_LOG_TRIVIAL(info) << "Platform: Emscripten";
+    s_platform        = Platform::Linux;
+    s_platform_flavor = PlatformFlavor::GenericLinux;
 #elif defined(__linux__)
     BOOST_LOG_TRIVIAL(info) << "Platform: Linux";
 	s_platform 		  = Platform::Linux;
diff --git a/src/libslic3r/Print.hpp b/src/libslic3r/Print.hpp
index 7261bc2ce6..fcecc5148f 100644
--- a/src/libslic3r/Print.hpp
+++ b/src/libslic3r/Print.hpp
@@ -861,8 +861,8 @@ public:
     // If preview_data is not null, the preview_data is filled in for the G-code visualization (not used by the command line Slic3r).
     std::string         export_gcode(const std::string& path_template, GCodeProcessorResult* result, ThumbnailsGeneratorCallback thumbnail_cb = nullptr);
     //return 0 means successful
-    int                 export_cached_data(const std::string& dir_path, bool with_space=false);
-    int                 load_cached_data(const std::string& directory);
+    int                 export_cached_data(const std::string& dir_path, bool with_space=false) override;
+    int                 load_cached_data(const std::string& directory) override;
 
     // methods for handling state
     bool                is_step_done(PrintStep step) const { return Inherited::is_step_done(step); }
diff --git a/src/libslic3r/PrintConfig.cpp b/src/libslic3r/PrintConfig.cpp
index 498678ad29..9224af6206 100644
--- a/src/libslic3r/PrintConfig.cpp
+++ b/src/libslic3r/PrintConfig.cpp
@@ -540,7 +540,7 @@ void PrintConfigDef::init_common_params()
     def->sidetext = L("layers");
     def->min      = 1;
     def->mode     = comAdvanced;
-    def->set_default_value(new ConfigOptionInt(1));	
+    def->set_default_value(new ConfigOptionInt(1));
 
     def = this->add("layer_height", coFloat);
     def->label = L("Layer height");
@@ -666,7 +666,7 @@ void PrintConfigDef::init_common_params()
     def->mode = comAdvanced;
     def->cli = ConfigOptionDef::nocli;
     def->set_default_value(new ConfigOptionEnum<AuthorizationType>(atKeyPassword));
-    
+
     // temporary workaround for compatibility with older Slicer
     {
         def = this->add("preset_name", coString);
@@ -825,7 +825,7 @@ void PrintConfigDef::init_fff_params()
     def->tooltip = L("Bed types supported by the printer.");
     def->mode = comSimple;
     def->enum_keys_map = &s_keys_map_BedType;
-    // Orca: make sure the order of the values is the same as the BedType enum 
+    // Orca: make sure the order of the values is the same as the BedType enum
     def->enum_values.emplace_back("Cool Plate");
     def->enum_values.emplace_back("Engineering Plate");
     def->enum_values.emplace_back("High Temp Plate");
@@ -1001,7 +1001,7 @@ void PrintConfigDef::init_fff_params()
     def->min = 0;
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionFloat(0.));
-    
+
     // ORCA: Internal bridge angle override
     def = this->add("internal_bridge_angle", coFloat);
     def->label = L("Internal bridge infill direction");
@@ -1184,7 +1184,7 @@ void PrintConfigDef::init_fff_params()
     def->tooltip = L("Enable this option to slow printing down for different overhang degree.");
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionBool{ true });
-    
+
     def = this->add("slowdown_for_curled_perimeters", coBool);
     def->label = L("Slow down for curled perimeters");
     def->category = L("Speed");
@@ -1506,7 +1506,7 @@ void PrintConfigDef::init_fff_params()
                        "consider turning it off if you are using large nozzles.");
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionBool(true));
-    
+
     def = this->add("enable_extra_bridge_layer", coEnum);
     def->label = L("Extra bridge layers (beta)");
     def->category = L("Quality");
@@ -1621,7 +1621,7 @@ void PrintConfigDef::init_fff_params()
     def->enum_labels.push_back(L("All"));
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionEnum<EnsureVerticalShellThickness>(EnsureVerticalShellThickness::evstAll));
-    
+
     auto def_top_fill_pattern = def = this->add("top_surface_pattern", coEnum);
     def->label = L("Top surface pattern");
     def->category = L("Strength");
@@ -1662,7 +1662,7 @@ void PrintConfigDef::init_fff_params()
     def->enum_values   = def_top_fill_pattern->enum_values;
     def->enum_labels   = def_top_fill_pattern->enum_labels;
     def->set_default_value(new ConfigOptionEnum<InfillPattern>(ipMonotonic));
-    
+
     def = this->add("outer_wall_line_width", coFloatOrPercent);
     def->label = L("Outer wall");
     def->category = L("Quality");
@@ -1891,7 +1891,7 @@ void PrintConfigDef::init_fff_params()
     def->max = 2;
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionFloats { 0.02 });
-    
+
     // Orca: Adaptive pressure advance option and calibration values
     def = this->add("adaptive_pressure_advance", coBools);
     def->label = L("Enable adaptive pressure advance (beta)");
@@ -1932,7 +1932,7 @@ void PrintConfigDef::init_fff_params()
     def->full_width = true;
     def->height = 15;
     def->set_default_value(new ConfigOptionStrings{"0,0,0\n0,0,0"});
-    
+
     // xgettext:no-c-format, no-boost-format
     def = this->add("adaptive_pressure_advance_overhangs", coBools);
     def->label = L("Enable adaptive pressure advance for overhangs (beta)");
@@ -2068,20 +2068,20 @@ void PrintConfigDef::init_fff_params()
 
     /*
         Large format printers with print volumes in the order of 1m^3 generally use pellets for printing.
-        The overall tech is very similar to FDM printing. 
+        The overall tech is very similar to FDM printing.
         It is FDM printing, but instead of filaments, it uses pellets.
 
-        The difference here is that where filaments have a filament_diameter that is used to calculate 
-        the volume of filament ingested, pellets have a particular flow_coefficient that is empirically 
+        The difference here is that where filaments have a filament_diameter that is used to calculate
+        the volume of filament ingested, pellets have a particular flow_coefficient that is empirically
         devised for that particular pellet.
 
         pellet_flow_coefficient is basically a measure of the packing density of a particular pellet.
         Shape, material and density of an individual pellet will determine the packing density and
-        the only thing that matters for 3d printing is how much of that pellet material is extruded by 
+        the only thing that matters for 3d printing is how much of that pellet material is extruded by
         one turn of whatever feeding mehcanism/gear your printer uses. You can emperically derive that
         for your own pellets for a particular printer model.
 
-        We are translating the pellet_flow_coefficient into filament_diameter so that everything works just like it 
+        We are translating the pellet_flow_coefficient into filament_diameter so that everything works just like it
         does already with very minor adjustments.
 
         filament_diameter = sqrt( (4 * pellet_flow_coefficient) / PI )
@@ -2110,7 +2110,7 @@ void PrintConfigDef::init_fff_params()
     def->min = 10;
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionPercents{ 100 });
-    
+
     def = this->add("filament_shrinkage_compensation_z", coPercents);
     def->label = L("Shrinkage (Z)");
     // xgettext:no-c-format, no-boost-format
@@ -2246,7 +2246,7 @@ void PrintConfigDef::init_fff_params()
     def->min = 0;
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionFloats { 10. });
-    
+
     def = this->add("filament_density", coFloats);
     def->label = L("Density");
     def->tooltip = L("Filament density. For statistics only.");
@@ -2377,7 +2377,7 @@ void PrintConfigDef::init_fff_params()
     def->min = 0;
     def->max = 100;
     def->set_default_value(new ConfigOptionPercent(20));
-        
+
     def           = this->add("align_infill_direction_to_model", coBool);
     def->label    = L("Align infill direction to model");
     def->category = L("Strength");
@@ -2621,7 +2621,7 @@ void PrintConfigDef::init_fff_params()
     def->tooltip = L("Klipper's max_accel_to_decel will be adjusted automatically.");
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionBool(true));
-    
+
     def = this->add("accel_to_decel_factor", coPercent);
     def->label = L("accel_to_decel");
     def->tooltip = L("Klipper's max_accel_to_decel will be adjusted to this %% of acceleration.");
@@ -2630,7 +2630,7 @@ void PrintConfigDef::init_fff_params()
     def->max = 100;
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionPercent(50));
-    
+
     def = this->add("default_jerk", coFloat);
     def->label = L("Default");
     def->tooltip = L("Default jerk.");
@@ -2780,7 +2780,7 @@ void PrintConfigDef::init_fff_params()
     def->max = 1000;
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionInts { 0 });
-    
+
     def = this->add("support_material_interface_fan_speed", coInts);
     def->label = L("Support interface fan speed");
     def->tooltip = L("This part cooling fan speed is applied when printing support interfaces. Setting this parameter to a higher than regular speed "
@@ -2792,7 +2792,7 @@ void PrintConfigDef::init_fff_params()
     def->max = 100;
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionInts{ -1 });
-    
+
     // ORCA: Add support for separate internal bridge fan speed control
     def = this->add("internal_bridge_fan_speed", coInts);
     def->label = L("Internal bridges fan speed");
@@ -2804,7 +2804,7 @@ void PrintConfigDef::init_fff_params()
     def->max = 100;
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionInts{ -1 });
-    
+
     def = this->add("ironing_fan_speed", coInts);
     def->label = L("Ironing fan speed");
     def->tooltip = L("This part cooling fan speed is applied when ironing. Setting this parameter to a lower than regular speed "
@@ -2942,7 +2942,7 @@ void PrintConfigDef::init_fff_params()
     def->sidetext = "mm";	// milimeters, don't need translation
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionFloat(0));
-    
+
     def = this->add("gap_infill_speed", coFloat);
     def->label = L("Gap infill");
     def->category = L("Speed");
@@ -3168,7 +3168,7 @@ void PrintConfigDef::init_fff_params()
                    "slow down.");
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionBool(0));
-    
+
     //BBS
     def = this->add("infill_combination", coBool);
     def->label = L("Infill combination");
@@ -3335,7 +3335,7 @@ void PrintConfigDef::init_fff_params()
     def->ratio_over = "inner_wall_line_width";
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionPercent(15));
-    
+
     def = this->add("top_bottom_infill_wall_overlap", coPercent);
     def->label = L("Top/Bottom solid infill/wall overlap");
     def->category = L("Strength");
@@ -3395,7 +3395,7 @@ void PrintConfigDef::init_fff_params()
     def->tooltip  = L("Interlocking depth of a segmented region. It will be ignored if "
                     "\"mmu_segmented_region_max_width\" is zero or if \"mmu_segmented_region_interlocking_depth\" "
                     "is bigger than \"mmu_segmented_region_max_width\". Zero disables this feature.");
-    def->sidetext = "mm";	// milimeters, don't need translation 
+    def->sidetext = "mm";	// milimeters, don't need translation
     def->min      = 0;
     def->category = L("Advanced");
     def->mode     = comAdvanced;
@@ -3484,7 +3484,7 @@ void PrintConfigDef::init_fff_params()
     def->enum_labels.push_back(L("Concentric"));
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionEnum<InfillPattern>(ipRectilinear));
-    
+
     def = this->add("ironing_flow", coPercent);
     def->label = L("Ironing flow");
     def->category = L("Quality");
@@ -3681,7 +3681,7 @@ void PrintConfigDef::init_fff_params()
             def->set_default_value(new ConfigOptionFloats(axis.max_jerk));
         }
     }
-    // M205 J... [mm] machine junction deviation limits 
+    // M205 J... [mm] machine junction deviation limits
     def = this->add("machine_max_junction_deviation", coFloats);
     def->full_label = L("Maximum Junction Deviation");
     def->category = L("Machine limits");
@@ -3793,11 +3793,11 @@ void PrintConfigDef::init_fff_params()
 
     def = this->add("max_volumetric_extrusion_rate_slope", coFloat);
     def->label = L("Extrusion rate smoothing");
-    def->tooltip = L("This parameter smooths out sudden extrusion rate changes that happen when " 
+    def->tooltip = L("This parameter smooths out sudden extrusion rate changes that happen when "
                      "the printer transitions from printing a high flow (high speed/larger width) "
                      "extrusion to a lower flow (lower speed/smaller width) extrusion and vice versa.\n\n"
                      "It defines the maximum rate by which the extruded volumetric flow in mm/s can change over time. "
-                     "Higher values mean higher extrusion rate changes are allowed, resulting in faster speed transitions.\n\n" 
+                     "Higher values mean higher extrusion rate changes are allowed, resulting in faster speed transitions.\n\n"
                      "A value of 0 disables the feature.\n\n"
                      "For a high speed, high flow direct drive printer (like the Bambu lab or Voron) this value is usually not needed. "
                      "However it can provide some marginal benefit in certain cases where feature speeds vary greatly. For example, "
@@ -3823,7 +3823,7 @@ void PrintConfigDef::init_fff_params()
     def->sidetext = "mm";	// milimeters, don't need translation
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionFloat(3.0));
-    
+
     def = this->add("extrusion_rate_smoothing_external_perimeter_only", coBool);
     def->label = L("Apply only on external features");
     def->tooltip = L("Applies extrusion rate smoothing only on external perimeters and overhangs. This can help reduce artefacts due to sharp speed transitions on externally visible "
@@ -3923,7 +3923,7 @@ void PrintConfigDef::init_fff_params()
     def->mode = comAdvanced;
     def->cli = ConfigOptionDef::nocli;
     def->set_default_value(new ConfigOptionEnum<PrintHostType>(htOctoPrint));
-    
+
 
     def = this->add("nozzle_volume", coFloat);
     def->label = L("Nozzle volume");
@@ -4079,7 +4079,7 @@ void PrintConfigDef::init_fff_params()
     def->min = 0;
     def->max = 1000;
     def->set_default_value(new ConfigOptionInt(2));
-    
+
     def = this->add("alternate_extra_wall", coBool);
     def->label = L("Alternate extra wall");
     def->category = L("Strength");
@@ -4088,7 +4088,7 @@ void PrintConfigDef::init_fff_params()
                      "Using lightning infill together with this option is not recommended as there is limited infill to anchor the extra perimeters to.");
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionBool(false));
-    
+
     def = this->add("post_process", coStrings);
     def->label = L("Post-processing Scripts");
     def->tooltip = L("If you want to process the output G-code through custom scripts, "
@@ -4101,7 +4101,7 @@ void PrintConfigDef::init_fff_params()
     def->height = 6;
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionStrings());
-    
+
     def = this->add("printer_model", coString);
     def->label = L("Printer type");
     def->tooltip = L("Type of the printer.");
@@ -4116,7 +4116,7 @@ void PrintConfigDef::init_fff_params()
     def->height = 13;
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionString());
-    
+
     def = this->add("printer_variant", coString);
     def->label = L("Printer variant");
     //def->tooltip = L("Name of the printer variant. For example, the printer variants may be differentiated by a nozzle diameter.");
@@ -4404,7 +4404,7 @@ void PrintConfigDef::init_fff_params()
     def->tooltip = L("This option causes the inner seams to be shifted backwards based on their depth, forming a zigzag pattern.");
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionBool(false));
-    
+
     def = this->add("seam_gap", coFloatOrPercent);
     def->label = L("Seam gap");
     def->tooltip = L("In order to reduce the visibility of the seam in a closed loop extrusion, the loop is interrupted and shortened by a specified amount.\n"
@@ -4520,7 +4520,7 @@ void PrintConfigDef::init_fff_params()
                      "e.g. if a wipe action is executed immediately following an outer wall extrusion, the speed of the outer wall extrusion will be utilized for the wipe action.");
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionBool(true));
-    
+
     def = this->add("wipe_on_loops", coBool);
     def->label = L("Wipe on loops");
     def->tooltip = L("To minimize the visibility of the seam in a closed loop extrusion, a small inward movement is executed before the extruder leaves the loop.");
@@ -4573,7 +4573,7 @@ void PrintConfigDef::init_fff_params()
     def->mode = comSimple;
     def->max = 10000;
     def->set_default_value(new ConfigOptionInt(1));
-    
+
     def = this->add("single_loop_draft_shield", coBool);
     def->label = L("Single loop after first layer");
     def->tooltip = L("Limits the skirt/draft shield loops to one wall after the first layer. This is useful, on occasion, to conserve filament but may cause the draft shield/skirt to warp / crack.");
@@ -4606,7 +4606,7 @@ void PrintConfigDef::init_fff_params()
     def->enum_labels.push_back(L("Per object"));
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionEnum<SkirtType>(stCombined));
-    
+
     def = this->add("skirt_loops", coInt);
     def->label = L("Skirt loops");
     def->full_label = L("Skirt loops");
@@ -4876,7 +4876,7 @@ void PrintConfigDef::init_fff_params()
     def->sidetext = "mm";	// milimeters, don't need translation
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionFloat(0));
-    
+
     def = this->add("enable_support", coBool);
     //BBS: remove material behind support
     def->label = L("Enable support");
@@ -5301,13 +5301,13 @@ void PrintConfigDef::init_fff_params()
     def->category = L("Quality");
     def->tooltip = L("Enabling this option means the height of tree support layer except the first will be automatically calculated.");
     def->set_default_value(new ConfigOptionBool(1));
-    
+
     def = this->add("tree_support_auto_brim", coBool);
     def->label = L("Auto brim width");
     def->category = L("Quality");
     def->tooltip = L("Enabling this option means the width of the brim for tree support will be automatically calculated.");
     def->set_default_value(new ConfigOptionBool(1));
-    
+
     def = this->add("tree_support_brim_width", coFloat);
     def->label = L("Tree support brim width");
     def->category = L("Quality");
@@ -5337,7 +5337,7 @@ void PrintConfigDef::init_fff_params()
     def->set_default_value(new ConfigOptionFloat(5.));
 
     def = this->add("tree_support_branch_diameter_angle", coFloat);
-    // TRN PrintSettings: #lmFIXME 
+    // TRN PrintSettings: #lmFIXME
     def->label = L("Branch Diameter Angle");
     def->category = L("Support");
     // TRN PrintSettings: "Organic supports" > "Branch Diameter Angle"
@@ -5375,7 +5375,7 @@ void PrintConfigDef::init_fff_params()
     def->tooltip = L("This setting specifies whether to add infill inside large hollows of tree support.");
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionBool(false));
-    
+
     def = this->add("support_ironing", coBool);
     def->label = L("Ironing Support Interface");
     def->category = L("Support");
@@ -5395,7 +5395,7 @@ void PrintConfigDef::init_fff_params()
     def->enum_labels.push_back(L("Concentric"));
     def->mode = comAdvanced;
     def->set_default_value(new ConfigOptionEnum<InfillPattern>(ipRectilinear));
-    
+
     def = this->add("support_ironing_flow", coPercent);
     def->label = L("Support Ironing flow");
     def->category = L("Support");
@@ -5697,7 +5697,7 @@ void PrintConfigDef::init_fff_params()
     def->min = 0.;
     def->max = 90.;
     def->set_default_value(new ConfigOptionFloat(30.0));
-    
+
     def = this->add("wipe_tower_max_purge_speed", coFloat);
     def->label = L("Maximum wipe tower print speed");
     def->tooltip = L("The maximum print speed when purging in the wipe tower and printing the wipe tower sparse layers. "
@@ -6910,7 +6910,7 @@ void PrintConfigDef::handle_legacy(t_config_option_key &opt_key, std::string &va
     static std::set<std::string> ignore = {
         "acceleration", "scale", "rotate", "duplicate", "duplicate_grid",
         "bed_size",
-        "print_center", "g0", "wipe_tower_per_color_wipe", 
+        "print_center", "g0", "wipe_tower_per_color_wipe",
         "support_sharp_tails","support_remove_small_overhangs", "support_with_sheath",
         "tree_support_collision_resolution", "tree_support_with_infill",
         "max_volumetric_speed", "max_print_speed",
@@ -7419,7 +7419,7 @@ std::map<std::string, std::string> validate(const FullPrintConfig &cfg, bool und
         for (unsigned char wipe : cfg.wipe.values)
              if (wipe)
                 error_message.emplace("use_firmware_retraction", "--use-firmware-retraction is not compatible with --wipe");
-                
+
     // --gcode-flavor
     if (! print_config_def.get("gcode_flavor")->has_enum_value(cfg.gcode_flavor.serialize())) {
         error_message.emplace("gcode_flavor", L("invalid value ") + cfg.gcode_flavor.serialize());
@@ -7454,7 +7454,7 @@ std::map<std::string, std::string> validate(const FullPrintConfig &cfg, bool und
     if (cfg.bridge_flow <= 0) {
         error_message.emplace("bridge_flow", L("invalid value ") + std::to_string(cfg.bridge_flow));
     }
-    
+
     // --bridge-flow-ratio
     if (cfg.bridge_flow <= 0) {
         error_message.emplace("internal_bridge_flow", L("invalid value ") + std::to_string(cfg.internal_bridge_flow));
@@ -8394,7 +8394,7 @@ static std::map<t_custom_gcode_key, t_config_option_keys> s_CustomGcodeSpecificP
     {"machine_pause_gcode",         {}},
     {"template_custom_gcode",       {}},
     // Filament G-code
-    {"filament_start_gcode",        {"filament_extruder_id"}},
+    {"filament_start_gcode",        {"layer_num", "layer_z", "max_layer_z", "filament_extruder_id", "long_retraction_when_cut", "retraction_distance_when_cut"}},
     {"filament_end_gcode",          {"layer_num", "layer_z", "max_layer_z", "filament_extruder_id"}},
 };
 
@@ -8424,6 +8424,14 @@ CustomGcodeSpecificConfigDef::CustomGcodeSpecificConfigDef()
     def->label = L("Filament extruder ID");
     def->tooltip = L("The current extruder ID. The same as current_extruder.");
 
+    def = this->add("long_retraction_when_cut", coBool);
+    def->label = L("Long retraction when cut");
+    def->tooltip = L("Whether long retraction is enabled for the current filament.");
+
+    def = this->add("retraction_distance_when_cut", coFloat);
+    def->label = L("Retraction distance when cut");
+    def->tooltip = L("Retraction distance to use when cutting filament.");
+
 // change_filament_gcode
     new_def("previous_extruder", coInt, "Previous extruder", "Index of the extruder that is being unloaded. The index is zero based (first extruder has index 0).");
     new_def("next_extruder", coInt, "Next extruder", "Index of the extruder that is being loaded. The index is zero based (first extruder has index 0).");
diff --git a/src/libslic3r/SLA/Hollowing.cpp b/src/libslic3r/SLA/Hollowing.cpp
index df62127770..ed3a1a2d4a 100644
--- a/src/libslic3r/SLA/Hollowing.cpp
+++ b/src/libslic3r/SLA/Hollowing.cpp
@@ -19,6 +19,53 @@
 //! return same string
 #define L(s) Slic3r::I18N::translate(s)
 
+#if defined(__EMSCRIPTEN__) && defined(ORCA_DISABLE_OPENVDB)
+
+namespace Slic3r {
+namespace sla {
+
+struct Interior {
+    indexed_triangle_set mesh;
+};
+
+void InteriorDeleter::operator()(Interior *p)
+{
+    delete p;
+}
+
+indexed_triangle_set &get_mesh(Interior &interior)
+{
+    return interior.mesh;
+}
+
+const indexed_triangle_set &get_mesh(const Interior &interior)
+{
+    return interior.mesh;
+}
+
+InteriorPtr generate_interior(const TriangleMesh &, const HollowingConfig &, const JobController &)
+{
+    return {};
+}
+
+void hollow_mesh(TriangleMesh &, const HollowingConfig &, int) {}
+
+void hollow_mesh(TriangleMesh &, const Interior &, int) {}
+
+void remove_inside_triangles(TriangleMesh &, const Interior &, const std::vector<bool> &) {}
+
+double get_distance(const Vec3f &, const Interior &)
+{
+    return 0.0;
+}
+
+void cut_drainholes(std::vector<ExPolygons> &, const std::vector<float> &, float, const DrainHoles &, std::function<void(void)>) {}
+
+} // namespace sla
+} // namespace Slic3r
+
+#else
+
 namespace Slic3r {
 namespace sla {
 
@@ -561,3 +608,5 @@ void remove_inside_triangles(TriangleMesh &mesh, const Interior &interior,
 }
 
 }} // namespace Slic3r::sla
+
+#endif // defined(__EMSCRIPTEN__) && defined(ORCA_DISABLE_OPENVDB)
diff --git a/src/libslic3r/Shape/TextShape.cpp b/src/libslic3r/Shape/TextShape.cpp
index dce731af19..95047f4e0b 100644
--- a/src/libslic3r/Shape/TextShape.cpp
+++ b/src/libslic3r/Shape/TextShape.cpp
@@ -6,7 +6,9 @@
 
 #include <string>
 #include <vector>
+#include <map>
 
+#ifndef SLIC3R_NO_OCCT
 #include "Standard_TypeDef.hxx"
 #include "STEPCAFControl_Reader.hxx"
 #include "BRepMesh_IncrementalMesh.hxx"
@@ -27,9 +29,12 @@
 #include "Font_BRepTextBuilder.hxx"
 #include "BRepPrimAPI_MakePrism.hxx"
 #include "Font_FontMgr.hxx"
+#endif
 
 #include <boost/log/trivial.hpp>
 
+#ifndef SLIC3R_NO_OCCT
+
 namespace Slic3r {
 
 static std::map<std::string, std::string> g_occt_fonts_maps; //map<font_name, font_path>
@@ -270,3 +275,27 @@ void load_text_shape(const char*text, const char* font, const float text_height,
 }
 
 }; // namespace Slic3r
+
+#else // SLIC3R_NO_OCCT
+
+namespace Slic3r {
+
+std::vector<std::string> init_occt_fonts()
+{
+    return {};
+}
+
+std::map<std::string, std::string> get_occt_fonts_maps()
+{
+    return {};
+}
+
+void load_text_shape(const char * /*text*/, const char * /*font*/, const float /*text_height*/, const float /*thickness*/, bool /*is_bold*/, bool /*is_italic*/, TextResult &text_result)
+{
+    text_result.text_mesh = TriangleMesh{};
+    text_result.text_width = 0.0;
+}
+
+} // namespace Slic3r
+
+#endif // SLIC3R_NO_OCCT
diff --git a/src/libslic3r/Support/SupportMaterial.cpp b/src/libslic3r/Support/SupportMaterial.cpp
index 7580976ac9..7866e2a97a 100644
--- a/src/libslic3r/Support/SupportMaterial.cpp
+++ b/src/libslic3r/Support/SupportMaterial.cpp
@@ -1587,7 +1587,7 @@ static inline std::tuple<Polygons, Polygons, double> detect_contacts(
 
         // Cache support trimming polygons derived from lower layer polygons, possible merged with "on build plate only" trimming polygons.
         auto slices_margin_update =
-            [&slices_margin, &layer, &lower_layer, &lower_layer_polygons, buildplate_only, has_enforcer, &annotations, layer_id]
+            [&slices_margin, &lower_layer, &lower_layer_polygons, buildplate_only, has_enforcer, &annotations, layer_id]
         (float slices_margin_offset, float no_interface_offset) {
             if (slices_margin.offset != slices_margin_offset) {
                 slices_margin.offset = slices_margin_offset;
diff --git a/src/libslic3r/Thread.cpp b/src/libslic3r/Thread.cpp
index 3030b6d194..52d25a4d8b 100644
--- a/src/libslic3r/Thread.cpp
+++ b/src/libslic3r/Thread.cpp
@@ -34,7 +34,7 @@ static bool WindowsGetSetThreadNameAPIInitialize()
 {
 	if (! s_SetGetThreadDescriptionInitialized) {
 		// Not thread safe! It is therefore a good idea to name the main thread before spawning worker threads
-		// to initialize 
+		// to initialize
 		s_hKernel32 = LoadLibraryW(L"Kernel32.dll");
 		if (s_hKernel32) {
 			s_fnSetThreadDescription = (SetThreadDescriptionType)::GetProcAddress(s_hKernel32, "SetThreadDescription");
@@ -137,7 +137,7 @@ bool set_thread_name(std::thread &thread, const char *thread_name)
 
 bool set_thread_name(boost::thread &thread, const char *thread_name)
 {
-// not supported	
+// not supported
 //   	pthread_setname_np(thread.native_handle(), thread_name);
 	return false;
 }
@@ -150,7 +150,7 @@ bool set_current_thread_name(const char *thread_name)
 
 std::optional<std::string> get_current_thread_name()
 {
-// not supported	
+// not supported
 //	char buf[16];
 //	return std::string(thread_getname_np(buf, 16) == 0 ? buf : "");
 	return std::nullopt;
@@ -158,6 +158,28 @@ std::optional<std::string> get_current_thread_name()
 
 #else
 
+#if defined(__EMSCRIPTEN__)
+// Emscripten runs single-threaded; pthread naming APIs are unavailable.
+bool set_thread_name(std::thread &, const char *)
+{
+	return false;
+}
+
+bool set_thread_name(boost::thread &, const char *)
+{
+	return false;
+}
+
+bool set_current_thread_name(const char *)
+{
+	return false;
+}
+
+std::optional<std::string> get_current_thread_name()
+{
+	return std::nullopt;
+}
+#else
 // posix
 bool set_thread_name(std::thread &thread, const char *thread_name)
 {
@@ -182,6 +204,7 @@ std::optional<std::string> get_current_thread_name()
 	char buf[16];
 	return std::string(pthread_getname_np(pthread_self(), buf, 16) == 0 ? buf : "");
 }
+#endif
 
 #endif
 
diff --git a/src/libslic3r/utils.cpp b/src/libslic3r/utils.cpp
index a493f6ebd1..8c1b128594 100644
--- a/src/libslic3r/utils.cpp
+++ b/src/libslic3r/utils.cpp
@@ -7,6 +7,7 @@
 #include <cstdarg>
 #include <stdio.h>
 #include <filesystem>
+#include <sstream>
 
 #include "format.hpp"
 #include "Platform.hpp"
@@ -43,6 +44,7 @@
 	#endif
 #endif
 
+#ifndef __EMSCRIPTEN__
 #include <boost/log/core.hpp>
 #include <boost/log/trivial.hpp>
 #include <boost/log/expressions.hpp>
@@ -52,6 +54,21 @@
 #include <boost/log/sources/severity_logger.hpp>
 #include <boost/log/sources/record_ostream.hpp>
 #include <boost/log/support/date_time.hpp>
+#else
+#include <iostream>
+#include <sstream>
+namespace boost { namespace log { namespace trivial {
+enum severity_level
+{
+	trace,
+	debug,
+	info,
+	warning,
+	error,
+	fatal
+};
+}}}
+#endif
 
 #include <boost/locale.hpp>
 
@@ -92,6 +109,61 @@ namespace Slic3r {
 
 static boost::log::trivial::severity_level logSeverity = boost::log::trivial::error;
 
+#ifdef __EMSCRIPTEN__
+namespace detail {
+template <boost::log::trivial::severity_level Severity>
+class LogStub {
+public:
+	LogStub() : m_enabled(Severity >= logSeverity) {}
+	~LogStub()
+	{
+		if (m_enabled && !m_stream.str().empty())
+			std::cout << '[' << severity_to_string() << "] " << m_stream.str() << std::endl;
+	}
+
+	template <typename T>
+	LogStub& operator<<(const T& value)
+	{
+		if (m_enabled)
+			m_stream << value;
+		return *this;
+	}
+
+	LogStub& operator<<(std::ostream& (*manip)(std::ostream&))
+	{
+		if (m_enabled)
+			manip(m_stream);
+		return *this;
+	}
+
+private:
+	static const char* severity_to_string()
+	{
+		switch (Severity) {
+		case boost::log::trivial::trace:   return "trace";
+		case boost::log::trivial::debug:   return "debug";
+		case boost::log::trivial::info:    return "info";
+		case boost::log::trivial::warning: return "warning";
+		case boost::log::trivial::error:   return "error";
+		case boost::log::trivial::fatal:   return "fatal";
+		default:                           return "log";
+		}
+	}
+
+	bool            m_enabled;
+	std::ostringstream m_stream;
+};
+
+template <boost::log::trivial::severity_level Severity>
+LogStub<Severity> make_log_stub()
+{
+	return LogStub<Severity>();
+}
+} // namespace detail
+
+#define BOOST_LOG_TRIVIAL(level) Slic3r::detail::make_log_stub<boost::log::trivial::level>()
+#endif // __EMSCRIPTEN__
+
 static boost::log::trivial::severity_level level_to_boost(unsigned level)
 {
     switch (level) {
@@ -114,10 +186,12 @@ void set_logging_level(unsigned int level)
 {
     logSeverity = level_to_boost(level);
 
+#ifndef __EMSCRIPTEN__
     boost::log::core::get()->set_filter
     (
         boost::log::trivial::severity >= logSeverity
     );
+#endif
 }
 
 unsigned int level_string_to_boost(std::string level)
@@ -159,7 +233,9 @@ unsigned get_logging_level()
     }
 }
 
+#ifndef __EMSCRIPTEN__
 boost::shared_ptr<boost::log::sinks::synchronous_sink<boost::log::sinks::text_file_backend>> g_log_sink;
+#endif
 
 // Force set_logging_level(<=error) after loading of the DLL.
 // This is currently only needed if libslic3r is loaded as a shared library into Perl interpreter
@@ -173,10 +249,15 @@ static struct RunOnInit {
 
 void trace(unsigned int level, const char *message)
 {
-    boost::log::trivial::severity_level severity = level_to_boost(level);
+    const boost::log::trivial::severity_level severity = level_to_boost(level);
 
+#ifndef __EMSCRIPTEN__
     BOOST_LOG_STREAM_WITH_PARAMS(::boost::log::trivial::logger::get(),\
         (::boost::log::keywords::severity = severity)) << message;
+#else
+    if (severity >= logSeverity)
+        std::cout << message << std::endl;
+#endif
 }
 
 void disable_multi_threading()
@@ -322,6 +403,7 @@ std::string debug_out_path(const char *name, ...)
 	return svg_folder.string() + std::string(buffer);
 }
 
+#ifndef __EMSCRIPTEN__
 namespace logging = boost::log;
 namespace src = boost::log::sources;
 namespace expr = boost::log::expressions;
@@ -371,6 +453,18 @@ void flush_logs()
 
 	return;
 }
+#else
+void set_log_path_and_level(const std::string& file, unsigned int level)
+{
+	(void)file;
+	set_logging_level(level);
+}
+
+void flush_logs()
+{
+	// No-op for Emscripten fallback logging.
+}
+#endif
 
 #ifdef _WIN32
 // The following helpers are borrowed from the LLVM project https://github.com/llvm
